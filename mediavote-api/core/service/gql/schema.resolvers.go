package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.21 DO NOT EDIT.

import (
	"context"
	"time"

	"github.com/nanozuki/crows.moe/mediavote-api/core/entity"
	"github.com/nanozuki/crows.moe/mediavote-api/core/port"
	"github.com/nanozuki/crows.moe/mediavote-api/graph"
	"github.com/nanozuki/crows.moe/mediavote-api/pkg/ierr"
)

// PostNominations is the resolver for the postNominations field.
func (r *mutationResolver) PostNomination(ctx context.Context, department entity.Department, workName string) ([]*entity.Nomination, error) {
	nomi, err := entity.NewNomination(department, workName)
	if err != nil {
		return nil, err
	}
	err = r.Repository.Nomination().Create(ctx, nomi)
	if err != nil && !ierr.IsErrCode(err, ierr.CodeDuplicatedObject) {
		return nil, err
	}
	return r.Resolver.Query().Nominations(ctx, department)
}

// PostBallot is the resolver for the postBallot field.
func (r *mutationResolver) PostBallot(ctx context.Context, input entity.BallotInput) (*entity.Ballot, error) {
	voterID := entity.CtxUserFromContext(ctx).VoterID
	ballots, err := r.Repository.Ballot().Search(ctx, &port.BallotQuery{
		VoterID:    voterID,
		Department: input.Department,
	})
	if err != nil {
		return nil, err
	}

	// not found new Ballot
	if len(ballots) == 0 {
		ballot, err := entity.NewBallot(voterID, input)
		if err != nil {
			return nil, err
		}
		if err := r.Repository.Ballot().Create(ctx, ballot); err != nil {
			return nil, err
		}
		return ballot, nil
	}

	// found, update Ballot
	ballot := ballots[0]
	ballot.SetCandidates(input.Candidates)
	if err := r.Repository.Ballot().UpdateOne(ctx, ballot.ID, &port.BallotUpdate{Candidates: ballot.Candidates}); err != nil {
		return nil, err
	}
	return ballots[0], nil
}

// Work is the resolver for the work field.
func (r *nominationResolver) Work(ctx context.Context, obj *entity.Nomination) (*entity.Work, error) {
	if obj.WorkID == nil {
		return nil, nil
	}
	return r.Repository.Work().GetByID(ctx, *obj.WorkID)
}

// Years is the resolver for the years field.
func (r *queryResolver) Years(ctx context.Context) ([]*entity.AnnualInfo, error) {
	return r.Repository.AnnualInfo().Search(ctx, &port.AnnualInfoQuery{Latest: true})
}

// ThisYear is the resolver for the thisYear field.
func (r *queryResolver) ThisYear(ctx context.Context) (*entity.AnnualInfo, error) {
	years, err := r.Repository.AnnualInfo().Search(ctx, &port.AnnualInfoQuery{Latest: true, Limit: 1})
	if err != nil {
		return nil, err
	}
	if len(years) == 0 {
		return &entity.AnnualInfo{Year: time.Now().Year(), Stage: entity.StageNotYet}, nil
	}
	return years[0], nil
}

// Awards is the resolver for the awards field.
func (r *queryResolver) Awards(ctx context.Context, year int) ([]*entity.Ranking, error) {
	return r.Repository.Ranking().Search(ctx, &port.RankingQuery{Year: year})
}

// Ballot is the resolver for the ballot field.
func (r *queryResolver) Ballot(ctx context.Context, year int) ([]*entity.Ballot, error) {
	return r.Repository.Ballot().Search(ctx, &port.BallotQuery{Year: year})
}

// Nominations is the resolver for the nominations field.
func (r *queryResolver) Nominations(ctx context.Context, department entity.Department) ([]*entity.Nomination, error) {
	return r.Repository.Nomination().Search(ctx, &port.NominationQuery{Department: department})
}

// Ranking is the resolver for the ranking field.
func (r *queryResolver) Ranking(ctx context.Context, department entity.Department) (*entity.Ranking, error) {
	rankings, err := r.Repository.Ranking().Search(ctx, &port.RankingQuery{Department: department})
	if err != nil {
		return nil, err
	}
	if len(rankings) == 0 {
		return nil, nil
	}
	return rankings[0], nil
}

// Voter is the resolver for the voter field.
func (r *queryResolver) Voter(ctx context.Context) (*entity.Voter, error) {
	voterID := entity.CtxUserFromContext(ctx).VoterID
	return r.Repository.Voter().GetByID(ctx, voterID)
}

// Ballot is the resolver for the ballot field.
func (r *voterResolver) Ballot(ctx context.Context, obj *entity.Voter, department entity.Department) (*entity.Ballot, error) {
	voterID := entity.CtxUserFromContext(ctx).VoterID
	ballots, err := r.Repository.Ballot().Search(ctx, &port.BallotQuery{
		VoterID:    voterID,
		Department: department,
	})
	if err != nil {
		return nil, err
	}
	if len(ballots) == 0 {
		return nil, nil
	}
	return ballots[0], nil
}

// Nominations is the resolver for the nominations field.
func (r *voterResolver) Nominations(ctx context.Context, obj *entity.Voter, department entity.Department) ([]*entity.Nomination, error) {
	return r.Repository.Nomination().Search(ctx, &port.NominationQuery{
		VoterID:    obj.ID,
		Department: department,
	})
}

// Work is the resolver for the Work field.
func (r *workRankingResolver) Work(ctx context.Context, obj *entity.WorkRanking) (*entity.Work, error) {
	return r.Repository.Work().GetByID(ctx, obj.WorkID)
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Nomination returns graph.NominationResolver implementation.
func (r *Resolver) Nomination() graph.NominationResolver { return &nominationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

// Voter returns graph.VoterResolver implementation.
func (r *Resolver) Voter() graph.VoterResolver { return &voterResolver{r} }

// WorkRanking returns graph.WorkRankingResolver implementation.
func (r *Resolver) WorkRanking() graph.WorkRankingResolver { return &workRankingResolver{r} }

type mutationResolver struct{ *Resolver }
type nominationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type voterResolver struct{ *Resolver }
type workRankingResolver struct{ *Resolver }
